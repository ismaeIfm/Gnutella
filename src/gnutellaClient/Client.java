package gnutellaClient;
import java.io.File;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.Scanner;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

public class Client implements Runnable {
	private short localPort;
	private boolean working;
	private ConcurrentHashMap<InetSocketAddress, ServentThread> neighbors;
	private ConcurrentHashMap<InetSocketAddress, ServentThread> downloads;

	private ConcurrentHashMap<String, InetSocketAddress> historyPing;
	private ConcurrentHashMap<String, InetSocketAddress> historyQuery;
	private ConcurrentHashMap<String, ArrayList<InetSocketAddress>> firstPongsFromNeighbors;
	private ConcurrentLinkedQueue<Message> pendingMessages;
	private ArrayList<QueryHitMessage> queryHitMessage;
	private InetSocketAddress myInetSocketAddress;
	private InetAddress ipAddress;
	private int numberFileShared;
	private int numberKbShared;
	private File myDirectory;
	private byte[] idServent;
	private int maxNodes;

	/**
	 * Creates a Client who manage sending/receiving Messages of the Gnutella
	 * protocol
	 * 
	 * @param localPort
	 *            * @param localPort Port in which the servent owner of this
	 *            client works
	 * @param neighbors
	 *            HashMap that contains the connections to its neighbors nodes.
	 *            Keys are in format InetSocketAddress, those InetSocketAddress
	 *            are bound with each connection(ServentThread).
	 * @param historyPing
	 *            HashMap that contains de history of every PingMessage received
	 *            from a neighbor Servent and every PingMessage generated by the
	 *            Servent that owns this Server
	 * @param historyQuery
	 *            HashMap that contains de history of every QueryMessage
	 *            received from a neighbor Servent and every QueryMessage
	 *            generated by the Servent that owns this Server
	 * @param pendingMessages
	 *            Queue which contains every message that needs to be process by
	 *            the Servent that owns this Server
	 * @param ipAddress
	 *            the ip address bound to this client
	 * @param myIdGenerator
	 *            Object to generate id
	 * @param myDirectory
	 *            DirectoryPath or file which, the Servent that owns this
	 *            Server, shares with the network
	 * @param idServent
	 *            The 16-byte string uniquely identifying the servent on the
	 *            network who is being requested to push
	 * @param downloads
	 *            HashMap that contains the connections to nodes which the
	 *            Servent owner of this Server has request for downloads and
	 *            connections to nodes that request for a download . Keys are in
	 *            format InetSocketAddress, those InetSocketAddress are bound
	 *            with each connection(ServentThread). Values are ServentThread.
	 * @param queryHitMessage
	 *            IO error when opening the socket in which this Server listens
	 *            for upcoming connections
	 */
	public Client(short localPort,
			ConcurrentHashMap<InetSocketAddress, ServentThread> neighbors,
			ConcurrentHashMap<String, InetSocketAddress> historyPing,
			ConcurrentHashMap<String, InetSocketAddress> historyQuery,
			ConcurrentLinkedQueue<Message> pendingMessages,
			InetAddress ipAddress, IdGenerator myIdGenerator, File myDirectory,
			byte[] idServent,
			ConcurrentHashMap<InetSocketAddress, ServentThread> downloads,
			ArrayList<QueryHitMessage> queryHitMessage) throws IOException {
		this.localPort = localPort;
		working = true;
		this.neighbors = neighbors;
		this.downloads = downloads;
		this.historyPing = historyPing;
		this.historyQuery = historyQuery;
		this.ipAddress = ipAddress;
		this.pendingMessages = pendingMessages;
		this.queryHitMessage = queryHitMessage;
		numberFileShared = 0;
		numberKbShared = 0;
		myInetSocketAddress = new InetSocketAddress(ipAddress, localPort);
		firstPongsFromNeighbors = new ConcurrentHashMap<String, ArrayList<InetSocketAddress>>();
		this.myDirectory = myDirectory;
		this.idServent = idServent;
		maxNodes = 10;
	}

	private synchronized void removeDeathConnections() {
		Enumeration<InetSocketAddress> e = neighbors.keys();
		while (e.hasMoreElements()) {
			InetSocketAddress iSA = e.nextElement();
			ServentThread sT = neighbors.get(iSA);
			if (!sT.getStillConnected()) {
				neighbors.remove(iSA);
			}
		}
	}

	public synchronized void setMaxNodes() {
		maxNodes++;
	}

	public synchronized int getMaxNodes() {
		return maxNodes;
	}

	/**
	 * Search that in the directory of the Servent owner of this Client exists a
	 * file with the specified name or a the name is a substring of another
	 * 
	 * @param file
	 *            The name of the file to search
	 * @return number of times the file matches
	 */
	public byte searchFile(String file) {
		byte hit = 0;
		String[] myFiles = myDirectory.list();

		for (int i = 0; i < myFiles.length; i++) {
			if (myFiles[i].contains(file)) {

				++hit;
			}

		}

		return hit;
	}

	/**
	 * Returns a PingMessage. MessageID is randomly generated. Ttl value is set
	 * by default to 7, hop to 0
	 * 
	 * @return the PingMessage
	 */
	public PingMessage createPing() {
		PingMessage m = new PingMessage(GnutellaConstants.DEFAULT_TTL,
				GnutellaConstants.INITIAL_HOP, myInetSocketAddress);
		return m;
	}

	private synchronized PongMessage createPong(byte[] messageId) {
		PongMessage pong = new PongMessage(messageId,
				GnutellaConstants.DEFAULT_TTL, (byte) 0, myInetSocketAddress,
				(short) myInetSocketAddress.getPort(), getIpAddress(),
				getNumberFileShared(), getNumberKbShared());
		return pong;
	}

	private Message createQuery(short minSpeed, String searchCriteria) {
		QueryMessage query = new QueryMessage(GnutellaConstants.DEFAULT_TTL,
				GnutellaConstants.INITIAL_HOP, 2 + searchCriteria.length(),
				myInetSocketAddress, minSpeed, searchCriteria);
		return query;
	}

	private Message createQueryHit(byte[] idMessage, int pL,
			InetSocketAddress receptorNode, byte numberOfHits, short port,
			InetAddress myIpAddress, int[] fileIndex, int[] fileSize,
			String[] fileName, byte[] idServent) {

		QueryHitMessage queryHit = new QueryHitMessage(idMessage,
				GnutellaConstants.DEFAULT_TTL, (byte) 0, pL,
				myInetSocketAddress, numberOfHits, port, ipAddress,
				GnutellaConstants.DFLT_SPEED, fileIndex, fileSize, fileName,
				idServent);
		return queryHit;
	}

	/**
	 * Adds a PingMessage to the pending Message queue
	 */
	public void addAPing() {
		// yo aÃ±adi este ping historial 1 id mensaje, 2 quien recibe 3 quien lo
		// manda
		Message messageTmp = createPing();
		historyPing.putIfAbsent(messageTmp.idMessageToString(),
				myInetSocketAddress);
		firstPongsFromNeighbors.putIfAbsent(messageTmp.idMessageToString(),
				new ArrayList<InetSocketAddress>());

		pendingMessages.add(messageTmp);
	}

	/**
	 * Adds a QuerMessage to the pending Message queue
	 * 
	 * @param minSpeed
	 *            The minimum speed (in kB/second) of servents that should
	 *            respond to this message.
	 * @param searchCriteria
	 *            A nul (i.e. 0x00) terminated search string. The maximum length
	 *            of this string is bounded by the Payload_Length field of the
	 *            descriptor header.
	 */
	public void addAQuery(short minSpeed, String searchCriteria) {
		Message messageTmp = createQuery(minSpeed, searchCriteria);
		historyQuery.putIfAbsent(messageTmp.idMessageToString(),
				myInetSocketAddress);
		pendingMessages.add(messageTmp);

	}

	@Override
	public void run() {
		int newPing = 1;
		while (working) {
			if (newPing % 10 == 0) {
				addAPing();
			}
			if (!pendingMessages.isEmpty()) {
				Message message = pendingMessages.poll();
				boolean fordward = message.refreshMessage();
				newPing++;
				switch (message.getPayloadD()) {

				case GnutellaConstants.PING:
					// Esta en mi historial
					
					if (historyPing.keySet().contains(
							message.idMessageToString())
							&& fordward) {
						// Si yo lo cree
						if (myInetSocketAddress.equals(message
								.getReceptorNode())) {
							Enumeration<InetSocketAddress> e = neighbors.keys();
							// Lo envio a todos mis nodos

							while (e.hasMoreElements()) {
								InetSocketAddress idNodeNext = e.nextElement();
								neighbors.get(idNodeNext)
										.messageToSend(message);
							}
							// yo no lo cree
						} else {
							// contesto al que lo envio
							neighbors.get(message.getReceptorNode())
									.messageToSend(
											createPong(message.getIdMessage()
													.toByteArray()));
							Enumeration<InetSocketAddress> e = neighbors.keys();
							// propago el ping
							while (e.hasMoreElements()) {

								InetSocketAddress idNodeNext = e.nextElement();
								// a todos los que no son el que lo recibio
								if (!idNodeNext.equals(message
										.getReceptorNode())) {

									neighbors.get(idNodeNext).messageToSend(
											message);
								}

							}

						}

					} else {
						// no tiene vida solo contesto
						neighbors.get(message.getReceptorNode())
								.messageToSend(
										createPong(message.getIdMessage()
												.toByteArray()));
					}

					break;
				case GnutellaConstants.PONG:
					PongMessage messageP = (PongMessage) message;

					// 3 casos es nuestro, no es nuestro, no debio de haber
					// llegado

					if (historyPing.keySet().contains(
							messageP.idMessageToString())) {

						// // Primer caso es nuestro

						InetSocketAddress ownerPing = historyPing.get(messageP
								.idMessageToString());
						if (myInetSocketAddress.equals(ownerPing)) {

							// No es el primer Pong que recibe este nodo
							if (firstPongsFromNeighbors.get(
									messageP.idMessageToString()).contains(
									messageP.getReceptorNode())) {

								connect(messageP.getIpAddressString(),
										messageP.getPort());

							} else { // Es el primer pong que recibe este nodo

								firstPongsFromNeighbors.get(
										messageP.idMessageToString()).add(
										messageP.getReceptorNode());

							}
						} else {
							// no es nuestro entonces lo envio por donde lo
							// pidieron

							neighbors.get(ownerPing).messageToSend(messageP);
						}

					} else {
						// EL PROTOCOLO DICE QUE SI ME LLEGA UN PONG DE UN PING
						// QUE NO CONOZCO DEBO SACAR EL PONG DE LA RED
						// PERO ESO YA LO HACEMOS AL HACER PULL SOBRE LA LISTA
						// DE MENSAJES

					}

					break;

				case GnutellaConstants.QUERY:

					QueryMessage queryMessage = (QueryMessage) message;

					// Esta en mi historial
					if (historyQuery.keySet().contains(
							queryMessage.idMessageToString())
							&& fordward) {
						// Si yo lo cree

						if (myInetSocketAddress.equals(queryMessage
								.getReceptorNode())) {
							Enumeration<InetSocketAddress> e = neighbors.keys();
							// Lo envio a todos mis nodos

							while (e.hasMoreElements()) {
								InetSocketAddress idNodeNext = e.nextElement();
								neighbors.get(idNodeNext).messageToSend(
										queryMessage);
							}
							// yo no lo cree
						} else {
							// verifico si tengo lo que pidio

							short hits = searchFile(queryMessage
									.getSearchCriteria());
							if (hits > 0) {
								// si lo tengo repondo con un query hit
								int i;
								String[] myFileN = myDirectory.list();
								File myFiles[] = myDirectory.listFiles();
								sortFilesDesc(myFiles);
								int fileIdx[] = new int[hits];
								String[] name = new String[hits];
								int[] size = new int[hits];
								int payloadL = GnutellaConstants.QUERYHIT_PART_L
										+ GnutellaConstants.SERVER_ID_L;
								int j = 0;
								for (i = 0; i < myFileN.length; i++) {
									if (myFileN[i].contains(queryMessage
											.getSearchCriteria())) {
										fileIdx[j] = i;
										name[j] = myFileN[i];

										size[j] = (int) myFiles[i].length();

										payloadL += size[j++];

									}

								}

								Message mQueryH = createQueryHit(message
										.getIdMessage().toByteArray(),
										payloadL, myInetSocketAddress,
										(byte) hits,
										(short) myInetSocketAddress.getPort(),
										ipAddress, fileIdx, size, name,
										idServent);
								
								neighbors.get(message.getReceptorNode())
										.messageToSend(mQueryH);

							}

							Enumeration<InetSocketAddress> e = neighbors.keys();

							// propago el query
							while (e.hasMoreElements()) {

								InetSocketAddress idNodeNext = e.nextElement();
								// a todos los que no son el que lo recibio
								if (!idNodeNext.equals(message
										.getReceptorNode())) {

									neighbors.get(idNodeNext).messageToSend(
											message);
								}

							}

						}

					} else {
						// no tiene vida solo
						// verifico si tengo lo que pidio
						byte hits = searchFile(queryMessage.getSearchCriteria());
						if (hits > 0) {

							int i;
							String[] myFileN = myDirectory.list();
							File myFiles[] = myDirectory.listFiles();
							sortFilesDesc(myFiles);
							int fileIdx[] = new int[hits];
							String[] name = new String[hits];
							int[] size = new int[hits];
							int payloadL = GnutellaConstants.QUERYHIT_PART_L
									+ GnutellaConstants.SERVER_ID_L;
							int j = 0;
							for (i = 0; i < myFileN.length; i++) {
								if (myFileN[i].contains(queryMessage
										.getSearchCriteria())) {
									fileIdx[j] = i;
									name[j] = myFileN[i];
									size[j] = myFileN[i].length();
									payloadL += size[j++];

								}

							}

							Message mQueryH = createQueryHit(message
									.getIdMessage().toByteArray(), payloadL,
									myInetSocketAddress, (byte) hits,
									(short) myInetSocketAddress.getPort(),
									ipAddress, fileIdx, size, name, idServent);
							
							neighbors.get(message.getReceptorNode())
									.messageToSend(mQueryH);

						}
					}
					break;

				case GnutellaConstants.QUERY_HIT:

					QueryHitMessage messageQH = (QueryHitMessage) message;
					//
					// // 3 casos es nuestro, no es nuestro, no debio de haber
					// // llegado
					//
					if (historyQuery.keySet().contains(
							messageQH.idMessageToString())) {

						//
						// // // Primer caso es nuestro
						//
						InetSocketAddress ownerQuery = historyQuery
								.get(messageQH.idMessageToString());
						if (myInetSocketAddress.equals(ownerQuery)) {
							
							queryHitMessage.add(messageQH);

						} else {
							neighbors.get(ownerQuery).messageToSend(messageQH);
							
						}
					} else {
						// EL PROTOCOLO DICE QUE SI ME LLEGA UN QUERY HIT DE UN
						// QUERY
						// QUE NO CONOZCO DEBO SACAR EL QUERYHIT DE LA RED
						// PERO ESO YA LO HACEMOS AL HACER PULL SOBRE LA LISTA
						// DE MENSAJES

					}
					//
					break;
				//

				}
			}
			removeDeathConnections();
		}
	}

	/**
	 * Returns the local port number to which this socket is bound.
	 * 
	 * @return the local port number
	 * */
	public short getLocalPort() {
		return localPort;
	}

	/**
	 * Returns the number of files that the servent is sharing on the network
	 * 
	 * @return number of files shared
	 */
	public synchronized int getNumberFileShared() {
		return numberFileShared;
	}

	/**
	 * Returns the number of kilobytes of data that the servent is sharing on
	 * the network
	 * 
	 * @return number of kilobytes shared
	 */
	public synchronized int getNumberKbShared() {
		return numberKbShared;
	}

	/**
	 * Returns the address of the Client
	 * 
	 * @return the address of the Client
	 */
	public synchronized InetAddress getIpAddress() {
		return ipAddress;
	}

	/**
	 * Creates a download connection with a Server with the specified data
	 * 
	 * @param ip
	 *            The IP address of the responding host.
	 * 
	 * @param port
	 *            The port number on which the responding host can accept
	 *            incoming connections.
	 * 
	 * @param file
	 *            The double-nul (i.e. 0x0000) terminated name of the file whose
	 *            index is File_Index.
	 * 
	 * @param size
	 *            The size (in bytes) of the file whose index is File_Index
	 * @param range
	 *            A number, assigned by the responding host, which is used to
	 *            uniquely identify the file matching the corresponding query.
	 */
	public synchronized void download(String ip, short port, String file,

	int size, int range) {
		if (downloads.size() <= GnutellaConstants.MAX_DOWNLOADS) {
			Socket sktTmp;

			try {
				sktTmp = new Socket(InetAddress.getByName(ip), port);

				InetSocketAddress inetSocketA = new InetSocketAddress(
						sktTmp.getInetAddress(), sktTmp.getLocalPort());
				ServentThread thread = new ServentThread(sktTmp, null, null,
						null, inetSocketA, myDirectory);
				if (thread.downloadRequest(file, size, range)) {
					downloads.putIfAbsent(inetSocketA, thread);

					new Thread(thread).start();

				} else {
					System.out.println("DENIED  DOWNLOAD CONNECTION");
				}
			} catch (UnknownHostException e) {

				e.printStackTrace();
			} catch (IOException e) {

				e.printStackTrace();
			}

		} else {
			System.out.println("MAX DOWNLOADS EXCEEDED");
		}
	}

	/**
	 * Creates a connection with to the specified port number at the specified
	 * IP address.
	 * 
	 * @param ip
	 *            the ip address
	 * @param port
	 *            the port number
	 * @return true if the connection is establish, otherwise false
	 */
	public synchronized boolean connect(String ip, short port) {
		if (neighbors.size() <= maxNodes) {
			ServentThread node;
			try {
				Socket sktTmp = new Socket(InetAddress.getByName(ip), port);
				InetSocketAddress inetSocketA = new InetSocketAddress(
						sktTmp.getInetAddress(), sktTmp.getLocalPort());
				node = new ServentThread(sktTmp, historyPing, historyQuery,
						pendingMessages, inetSocketA, myDirectory);

				if (node.connexionRequest() == GnutellaConstants.ACCEPTED) {

					neighbors.putIfAbsent(inetSocketA, node);
					new Thread(node).start();
					return true;
				}
			} catch (UnknownHostException e) {

				e.printStackTrace();
			} catch (IOException e) {

				e.printStackTrace();
			}
			System.out.println("DENIED CONNECCTION");

			return false;
		}

		return false;
	}

	private static void sortFilesDesc(File[] files) {
		Comparator<File> comparator = new Comparator<File>() {

			@Override
			public int compare(File o1, File o2) {
				return Long.valueOf(o1.lastModified()).compareTo(
						o2.lastModified());
			}
		};
		Arrays.sort(files, comparator);

	}
}
