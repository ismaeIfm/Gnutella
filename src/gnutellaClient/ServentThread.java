package gnutellaClient;

import java.io.*;

import java.net.*;
import java.math.BigInteger;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Class for managing the connections created by a Servent
 * 
 * @author Ismael Fernandez
 * @author Miguel Vilchis
 * 
 */

public class ServentThread implements Runnable {
	/* Atributos siempre usados */
	private InputStream in;
	private DataInputStream inStream;
	private OutputStream out;
	private DataOutputStream outStream;
	private Socket mySkt;
	private byte[] idServent;
	private boolean downloadThread;

	/* Atributos del nodo cuando es un servent */
	private ConcurrentHashMap<String, InetSocketAddress> historyPing;
	private ConcurrentHashMap<String, InetSocketAddress> historyQuery;
	private ConcurrentHashMap<InetSocketAddress, Boolean> firstPongsFromNeighbors;
	private ConcurrentLinkedQueue<Message> pendingMessages;
	private ConcurrentLinkedQueue<Message> messagesToSend;
	private MessageHandler messageHandler;
	private InetSocketAddress inSktA;
	private boolean working;
	private boolean stillConnected;
	private boolean flag;

	/* Atributos del nodo cuando es para descarga */

	private BigInteger fileLength;
	private String fileName;
	private String typeConnection;
	private BigInteger rangeByte;
	private boolean downloadFinished;
	private boolean server;
	private File myDir;

	/**
	 * Creates a ServentThread to manage the connection bound in the specified
	 * socket
	 * 
	 * @param mySocket
	 *            Socket bound to the connection that this object represents
	 * @param historyPing
	 *            HashMap that contains de history of every PingMessage received
	 *            from a neighbor Servent and every PingMessage generated by the
	 *            Servent that owns this Server
	 * @param historyQuery
	 *            HashMap that contains de history of every QueryMessage
	 *            received from a neighbor Servent and every QueryMessage
	 *            generated by the Servent that owns this Server
	 * @param pendingMessages
	 * @param inSkA
	 *            InetSocketAddress bound to this connection
	 * @param pathName
	 *            Name directoryPath or file which, the Servent that owns this
	 *            Server, shares with the network
	 */
	public ServentThread(Socket mySocket,
			ConcurrentHashMap<String, InetSocketAddress> historyPing,
			ConcurrentHashMap<String, InetSocketAddress> historyQuery,
			ConcurrentLinkedQueue<Message> pendingMessages,
			InetSocketAddress inSkA, File pathName) {

		this.mySkt = mySocket;
		this.historyPing = historyPing;
		this.historyQuery = historyQuery;
		this.pendingMessages = pendingMessages;
		this.inSktA = inSkA;
		messagesToSend = new ConcurrentLinkedQueue<Message>();
		InetSocketAddress mine = new InetSocketAddress(
				mySocket.getInetAddress(), getPort());
		messageHandler = new MessageHandler(mine);

		working = true;
		downloadThread = false;
		downloadFinished = false;
		this.myDir = pathName;
		stillConnected = true;

	}

	// //////////////////////////////////////////////////////////////////////////////////////////////////
	/* METHODS USED IF DOWNLOADTHREAD */

	/**
	 * Returns the name of the file this connection is managing
	 * 
	 * @return
	 */
	public int getFileLength() {
		return fileLength.intValue();
	}

	/**
	 * Returns boolean that determines if the download has finished
	 * 
	 * @return true if is finished, false otherwise
	 * 
	 */
	public boolean getDownloadFinished() {
		return downloadFinished;
	}

	/**
	 * Returns the number of bytes that before this connection started had been
	 * download of the file
	 * 
	 * @return the number of bytes
	 */
	public int getRangeByte() {

		return rangeByte.intValue();
	}

	/**
	 * Returns the file name that this network is managing
	 * 
	 * @return the name of the file
	 */
	public synchronized String getFileName() {
		if (!downloadThread) {

		}
		return fileName;
	}

	/**
	 * Returns the port of the connection
	 * 
	 * @return the port
	 */
	public int getPort() {
		return inSktA.getPort();
	}

	// //////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/* METHODS USED IF NOT DOWNLOADTHREAD */
	/**
	 * Adds the Message to the queue of pending messages to send
	 * 
	 * @param m
	 *            the Message
	 */
	public void messageToSend(Message m) {
		messagesToSend.add(m);

	}

	public synchronized boolean getStillConnected() {
		return stillConnected;
	}

	// /////////////////////////////////////////////////////////////////////////////////////////////////
	/* METHODS USED ALWAYS */

	/**
	 * Close this connection
	 */
	public void close() {
		stillConnected = false;
		working = false;
		downloadFinished = true;
	}

	/**
	 * Send a Gnutella connection request string to the servent with which is
	 * connected
	 * 
	 * @return true if the servent responds accepting the connection request.
	 *         False other any other answer
	 * 
	 */
	public boolean connexionRequest() {
		try {
			out = mySkt.getOutputStream();
			outStream = new DataOutputStream(out);
			in = mySkt.getInputStream();
			inStream = new DataInputStream(in);
			outStream.writeUTF(GnutellaConstants.CONNECTION_REQUEST);
			if (inStream.readUTF()
					.equals(GnutellaConstants.CONNECTION_ACCEPTED)) {
				return true;
			}
			inStream.close();
			in.close();
			outStream.close();
			out.close();
			mySkt.close();

			return false;

		} catch (IOException e) {
			System.err.println(getClass() + ".establishConnexion():"
					+ e.getClass() + e.getMessage());
			e.printStackTrace();
			return false;

		}

	}

	/**
	 * * Send a HTTP download request string to the server with which is
	 * connected
	 * 
	 * @param file
	 *            Name of the file of the request
	 * @param size
	 *            Size of the file of the request
	 * @param range
	 *            Number of bytes that have been download from this file
	 * @return true if the request is accepted, otherwise false
	 */
	public boolean downloadRequest(String file, int size, int range) {
		try {
			this.rangeByte = new BigInteger(range + "");
			this.fileLength = new BigInteger(size + "");
			this.fileName = file;
			out = mySkt.getOutputStream();
			outStream = new DataOutputStream(out);
			in = mySkt.getInputStream();
			inStream = new DataInputStream(in);
			String request = GnutellaConstants.HTTP_GETPART + size + "/" + file
					+ GnutellaConstants.HTTP_REST + range + "\r\n\r\n";
			outStream.writeUTF(request);
			String answer = inStream.readUTF();
			if (answer.equals(GnutellaConstants.HTTP_OK + size + "\r\n\r\n")) {
				downloadThread = true;
				return true;
			}
			inStream.close();
			in.close();
			outStream.close();
			out.close();
			mySkt.close();
			return false;
		} catch (IOException e) {
			System.err.println(getClass() + ".downloadConnexion():"
					+ e.getClass() + e.getMessage());
			e.printStackTrace();
			return false;
		}
	}

	/**
	 * Verifies the if the servent received a connection request or download
	 * request.
	 * 
	 * @return An integer: 1 Connection Request, 2 Download Request, 3
	 *         Everything else
	 */
	public int establishConnection() {
		try {
			in = mySkt.getInputStream();
			inStream = new DataInputStream(in);
			// A servent
			// may reject an incoming connection request for a variety of
			// reasons - a serventâ€™s pool of incoming
			// connection slots may be exhausted
			String request = inStream.readUTF();
			if (request.equals(GnutellaConstants.CONNECTION_REQUEST)) {
				out = mySkt.getOutputStream();
				outStream = new DataOutputStream(out);
				outStream.writeUTF(GnutellaConstants.CONNECTION_ACCEPTED);

				System.out.println("A Servent has successfully connected");
				return GnutellaConstants.SERVENT_NODE;
			} else {

				try {
					String[] requestDes = request.split("\r\n");
					String[] get = requestDes[0].split("/");

					String connection[] = requestDes[1].split(" ");

					String range[] = requestDes[2].split(" ");
					String bytes[] = range[1].split("=");

					if (requestDes.length != 3
							|| !get[0].equals(GnutellaConstants.HTTP_GET)
							|| !get[1].equals(GnutellaConstants.HTTP_GETLC)

							|| !get[4].equals(GnutellaConstants.HTTP_STRING)
							|| !get[5].equals(GnutellaConstants.HTTP_VERSION)
							|| !connection[0]
									.equals(GnutellaConstants.HTTP_CONNECTION)
							|| !range[0].equals(GnutellaConstants.HTTP_RANGE)
							|| !bytes[0].equals(GnutellaConstants.HTTP_BYTES)) {

						return GnutellaConstants.FAILURE_NODE;

					}

					this.fileLength = new BigInteger(get[2]);
					this.fileName = get[3];
					this.typeConnection = connection[1];
					;
					this.rangeByte = new BigInteger(bytes[1].substring(0,
							bytes.length - 1));
					if (getRangeByte() > getFileLength()) {
						return GnutellaConstants.FAILURE_NODE;
					}

					out = mySkt.getOutputStream();
					outStream = new DataOutputStream(out);

					File fileN[] = myDir.listFiles();
					boolean b = false;
					for (File a : fileN) {
						if ((a.getName().trim()).equals(fileName.trim())
								&& a.length() != 0) {

							outStream.writeUTF(GnutellaConstants.HTTP_OK
									+ getFileLength() + "\r\n\r\n");

							downloadThread = true;
							server = true;
							return GnutellaConstants.DOWNLOAD_NODE;

						}

					}
					outStream.writeUTF(GnutellaConstants.HTTP_DENY);
					return GnutellaConstants.FAILURE_NODE;

				} catch (Exception e) {

					return GnutellaConstants.FAILURE_NODE;
				}

			}

		} catch (IOException e) {
			System.err.println(getClass() + ".connecxionRequest(): "
					+ e.getClass() + e.getMessage());
		}
		return GnutellaConstants.FAILURE_NODE;

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Runnable#run()
	 */
	public void run() {
		flag = true;
		if (!downloadThread) {
			while (working) {
				if (!messagesToSend.isEmpty()) {
					try {

						if (messagesToSend.peek().getPayloadD() == GnutellaConstants.PING) {
							flag = false;
							new java.util.Timer().schedule(
									new java.util.TimerTask() {
										@Override
										public void run() {
											if (flag == false) {
												close();
											}
										}
									}, 10000);
						}

						outStream.write(messagesToSend.poll().toByteArray());

					} catch (IOException e) {

					}
				}
				try {

					while (inStream.available() > 0) {
						// En este momento leerÃ© algo que esta en el flujo
						Message m = messageHandler.getMessage(inStream);
						String message = m.idMessageToString();
						InetSocketAddress inetSckAd = new InetSocketAddress(
								mySkt.getInetAddress(), getPort());
						flag = true;
						switch (m.getPayloadD()) {
						case GnutellaConstants.PING:
							if (!historyPing.keySet().contains(message)) {
								historyPing.putIfAbsent(message, inetSckAd);
								pendingMessages.add(m);
							}

							break;
						case GnutellaConstants.PONG:
							
							pendingMessages.add(m);
							break;

						case GnutellaConstants.PUSH:
							break;
						case GnutellaConstants.QUERY:

							if (!historyQuery.keySet().contains(message)) {
								historyQuery.putIfAbsent(message, inetSckAd);
								pendingMessages.add(m);
							}
							break;
						case GnutellaConstants.QUERY_HIT:
							pendingMessages.add(m);
							break;

						}

					}
				} catch (IOException e) {
					System.err.println(getClass() + "run(): " + e.getClass()
							+ e.getMessage());
				}
			}

			try {
				inStream.close();
				in.close();
				outStream.close();
				out.close();
				mySkt.close();
			} catch (IOException e) {
				System.err.println(getClass() + "run(): " + e.getClass()
						+ e.getMessage());
			}
		} else {

			if (server) {

				try {

					RandomAccessFile f = new RandomAccessFile(myDir.getPath()
							+ "/" + getFileName(), "r");

					byte[] b = new byte[(int) f.length()];

					f.read(b);

					byte aux[] = new byte[b.length - getRangeByte()];
					for (int i = 0; i < aux.length; i++) {
						aux[i] = b[i + getRangeByte()];

					}
					outStream.write(aux);

					downloadFinished = true;
				} catch (FileNotFoundException e) {
					System.err.println("Your file wasn't found");

				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				try {

					while (!downloadFinished) {
						ArrayList<Byte> file = new ArrayList<Byte>();
						int currentSize = 0 + getRangeByte();

						while (inStream.available() > 0
								&& currentSize <= getFileLength()) {

							file.add(inStream.readByte());
							currentSize++;

						}

						byte[] fb = new byte[currentSize];

						for (int j = 0; j < fb.length; j++) {
							fb[j] = file.get(j);

						}
						
						FileOutputStream fos = new FileOutputStream(new File(
								myDir.getPath() + "/" + getFileName()));

						fos.write(fb);
						fos.close();
						downloadFinished = true;
					}
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				downloadFinished = true;
			}

		}
	}
}
