package gnutellaClient;
import java.io.File;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Enumeration;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

import javax.xml.soap.Node;

/**
 * Class that represents the Server part of Gnutella Servent
 * 
 * @author Ismael Fernandez
 * @author Miguel Alonso Vilchis
 * 
 */
public class Server implements Runnable {
	private ServerSocket mySkt;
	private int myPort;
	private ConcurrentHashMap<InetSocketAddress, ServentThread> neighbors;
	private ConcurrentHashMap<InetSocketAddress, ServentThread> downloads;
	private ConcurrentHashMap<String, InetSocketAddress> historyPing;
	private ConcurrentHashMap<String, ConcurrentHashMap<InetSocketAddress, Boolean>> firstPongsFromNeighbors;
	private ConcurrentHashMap<String, InetSocketAddress> historyQuery;
	private ConcurrentLinkedQueue<Message> pendingMessages;
	private boolean listening;
	private IdGenerator myIdGenerator;
	private File myDirectory;
	private int maxNodes;

	/**
	 * Creates a Server that listen for upcoming connections on the specified
	 * port.
	 * 
	 * @param myPort
	 *            Port in which the server will wait for upcoming connections
	 * @param neighbors
	 *            HashMap that contains the connections to its neighbors nodes.
	 *            Keys are in format InetSocketAddress, those InetSocketAddress
	 *            are bound with each connection(ServentThread).
	 * @param historyPing
	 *            HashMap that contains de history of every PingMessage received
	 *            from a neighbor Servent and every PingMessage generated by the
	 *            Servent that owns this Server
	 * @param historyQuery
	 *            HashMap that contains de history of every QueryMessage
	 *            received from a neighbor Servent and every QueryMessage
	 *            generated by the Servent that owns this Server
	 * @param pendingMessages
	 *            Queue which contains every message that needs to be process by
	 *            the Servent that owns this Server
	 * @param myIdGenerator
	 *            Object to generate id
	 * @param downloads
	 *            HashMap that contains the connections to nodes which the
	 *            Servent owner of this Server has request for downloads and
	 *            connections to nodes that request for a download . Keys are in
	 *            format InetSocketAddress, those InetSocketAddress are bound
	 *            with each connection(ServentThread). Values are ServentThread.
	 * @param myDirectory
	 *            DirectoryPath or file which, the Servent that owns this
	 *            Server, shares with the network
	 * @throws IOException
	 *             IO error when opening the socket in which this Server listens
	 *             for upcoming connections
	 */
	public Server(int myPort,
			ConcurrentHashMap<InetSocketAddress, ServentThread> neighbors,
			ConcurrentHashMap<String, InetSocketAddress> historyPing,
			ConcurrentHashMap<String, InetSocketAddress> historyQuery,
			ConcurrentLinkedQueue<Message> pendingMessages,
			IdGenerator myIdGenerator,
			ConcurrentHashMap<InetSocketAddress, ServentThread> downloads,
			File myDirectory) throws IOException {
		mySkt = new ServerSocket(myPort);
		this.myPort = myPort;
		this.neighbors = neighbors;
		this.downloads = downloads;
		this.historyPing = historyPing;
		this.historyQuery = historyQuery;
		this.pendingMessages = pendingMessages;
		listening = true;
		this.myIdGenerator = myIdGenerator;
		this.myDirectory = myDirectory;
		maxNodes = 5;

	}

	@Override
	public void run() {
		while (listening) {
			try {
				Socket skt = mySkt.accept();
				InetSocketAddress key = new InetSocketAddress(
						skt.getInetAddress(), skt.getPort());

				// Crea un nuevo thread para cada nueva conexion
				ServentThread thread = new ServentThread(skt, historyPing,
						historyQuery, pendingMessages, key, myDirectory);

				// Decide que tipo de conexion es la entrante
				switch (thread.establishConnection()) {

				case GnutellaConstants.DOWNLOAD_NODE:
					if (downloads.size() <= GnutellaConstants.MAX_DOWNLOADS) {

						downloads.putIfAbsent(key, thread);
						new Thread(thread).start();
					} else {
						thread.close();
					}
					break;
				case GnutellaConstants.SERVENT_NODE:
					if (neighbors.size() <= 10) {
						neighbors.putIfAbsent(key, thread);
						new Thread(thread).start();
					} else {
						thread.close();
					}

					break;
				default:
					thread.close();
					break;

				}

				removeCompleteDownload();

			} catch (IOException e) {

				e.printStackTrace();
			}
		}
	}

	public void setMaxNodes() {
		maxNodes++;
	}

	/**
	 * Delete connections with completed downloads.
	 */
	public void removeCompleteDownload() {
		Enumeration<InetSocketAddress> e = downloads.keys();
		while (e.hasMoreElements()) {
			InetSocketAddress iSA = e.nextElement();
			ServentThread sT = downloads.get(iSA);
			if (sT.getDownloadFinished()) {
				downloads.remove(iSA);
			}
		}

	}
}
